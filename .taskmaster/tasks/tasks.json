{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Database Schema Setup - Wizard Sessions Table",
        "description": "Create the wizard_sessions table with proper schema, indexes, and RLS policies to support the 6-stage event creation wizard with auto-save functionality.",
        "details": "Create migration file for wizard_sessions table with fields: id (UUID PK), user_id (UUID FK to profiles), event_id (UUID nullable FK to events), stage (INTEGER 1-6), status (TEXT: in_progress/completed/abandoned), state (JSONB for form data), started_at, last_saved_at, completed_at (all TIMESTAMPTZ). Add indexes on user_id, status, last_saved_at for performance. Implement RLS policy allowing users to only access their own sessions. SQL: CREATE TABLE wizard_sessions (...); CREATE INDEX idx_wizard_sessions_user_id ON wizard_sessions(user_id); CREATE POLICY wizard_sessions_policy ON wizard_sessions FOR ALL USING (auth.uid() = user_id);",
        "testStrategy": "Test table creation, verify indexes exist, test RLS policy by attempting cross-user access, validate all field types and constraints, test foreign key relationships.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Supabase Migration File for wizard_sessions Table",
            "description": "Create a new Supabase migration file to define the wizard_sessions table schema with all required fields and constraints.",
            "dependencies": [],
            "details": "Create migration file in supabase/migrations/ directory with SQL to create wizard_sessions table. Include fields: id (UUID PRIMARY KEY DEFAULT gen_random_uuid()), user_id (UUID REFERENCES profiles(id) ON DELETE CASCADE), event_id (UUID REFERENCES events(id) ON DELETE SET NULL), stage (INTEGER CHECK (stage >= 1 AND stage <= 6)), status (TEXT CHECK (status IN ('in_progress', 'completed', 'abandoned'))), state (JSONB NOT NULL DEFAULT '{}'), started_at (TIMESTAMPTZ DEFAULT NOW()), last_saved_at (TIMESTAMPTZ DEFAULT NOW()), completed_at (TIMESTAMPTZ).",
            "status": "pending",
            "testStrategy": "Run migration locally, verify table creation with correct schema, test all field constraints and data types, validate foreign key relationships work correctly."
          },
          {
            "id": 2,
            "title": "Add Database Indexes for Performance Optimization",
            "description": "Create database indexes on wizard_sessions table for optimal query performance on frequently accessed columns.",
            "dependencies": [
              1
            ],
            "details": "Add indexes in the same migration file: CREATE INDEX idx_wizard_sessions_user_id ON wizard_sessions(user_id); CREATE INDEX idx_wizard_sessions_status ON wizard_sessions(status); CREATE INDEX idx_wizard_sessions_last_saved_at ON wizard_sessions(last_saved_at); CREATE INDEX idx_wizard_sessions_user_status ON wizard_sessions(user_id, status) for composite queries.",
            "status": "pending",
            "testStrategy": "Verify indexes are created successfully, test query performance improvements, validate index usage with EXPLAIN ANALYZE on common queries."
          },
          {
            "id": 3,
            "title": "Implement Row Level Security (RLS) Policies",
            "description": "Set up RLS policies on wizard_sessions table to ensure users can only access their own wizard session data.",
            "dependencies": [
              2
            ],
            "details": "Enable RLS and create policies: ALTER TABLE wizard_sessions ENABLE ROW LEVEL SECURITY; CREATE POLICY wizard_sessions_policy ON wizard_sessions FOR ALL USING (auth.uid() = user_id); CREATE POLICY wizard_sessions_insert_policy ON wizard_sessions FOR INSERT WITH CHECK (auth.uid() = user_id); Test policy enforcement for SELECT, INSERT, UPDATE, DELETE operations.",
            "status": "pending",
            "testStrategy": "Test RLS policy by attempting cross-user access with different authenticated users, verify policy blocks unauthorized access, test all CRUD operations respect user isolation."
          },
          {
            "id": 4,
            "title": "Create Database Helper Functions and Triggers",
            "description": "Implement database functions and triggers for automatic timestamp updates and session state management.",
            "dependencies": [
              3
            ],
            "details": "Create trigger function to automatically update last_saved_at on state changes: CREATE OR REPLACE FUNCTION update_wizard_session_timestamp() RETURNS TRIGGER AS $$ BEGIN NEW.last_saved_at = NOW(); RETURN NEW; END; $$ LANGUAGE plpgsql; CREATE TRIGGER update_wizard_session_timestamp BEFORE UPDATE ON wizard_sessions FOR EACH ROW EXECUTE FUNCTION update_wizard_session_timestamp();",
            "status": "pending",
            "testStrategy": "Test trigger fires on UPDATE operations, verify last_saved_at timestamp updates automatically, test trigger doesn't interfere with other operations, validate function executes without errors."
          },
          {
            "id": 5,
            "title": "Validate Complete Schema Integration",
            "description": "Perform comprehensive testing of the complete wizard_sessions table setup including all constraints, relationships, and policies.",
            "dependencies": [
              4
            ],
            "details": "Run full integration tests: test table creation with sample data, validate all field constraints work correctly, test foreign key relationships with profiles and events tables, verify RLS policies function properly, test index performance with sample queries, validate triggers execute correctly, test edge cases like null values and boundary conditions.",
            "status": "pending",
            "testStrategy": "Create comprehensive test suite covering all table functionality, test with various user scenarios, validate data integrity constraints, perform load testing on indexes, verify complete schema works with existing codebase."
          }
        ]
      },
      {
        "id": 2,
        "title": "Zustand Store and Auto-Save System",
        "description": "Implement Zustand store for wizard state management with auto-save functionality that saves every 30 seconds, on navigation, and on field blur.",
        "details": "Create wizardStore.ts with Zustand store containing: wizardState (form data for all 6 stages), currentStage, sessionId, saveStatus (saving/saved/error), lastSaved timestamp. Implement auto-save hook with debouncing (30s), save on stage navigation, save on blur for text inputs. Add visual save indicators. Functions: initializeSession(), saveWizardState(), updateStage(), resetWizard(). Use React Query for API calls to Supabase. Handle offline scenarios with localStorage backup. Code: const useWizardStore = create((set, get) => ({ wizardState: {}, currentStage: 1, saveStatus: 'saved', actions: { saveState: debounce(async () => { ... }, 30000) } }));",
        "testStrategy": "Test auto-save triggers every 30 seconds, verify save on navigation between stages, test save on field blur, validate visual indicators update correctly, test offline/online scenarios, verify localStorage backup functionality.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Zustand Store Structure and Types",
            "description": "Set up the core Zustand store with TypeScript interfaces and initial state structure for wizard management.",
            "dependencies": [],
            "details": "Create wizardStore.ts with TypeScript interfaces for WizardState, SaveStatus, and store actions. Define the store structure with wizardState (form data for all 6 stages), currentStage, sessionId, saveStatus (saving/saved/error), lastSaved timestamp. Initialize empty state objects for each stage and implement basic getter/setter actions.",
            "status": "pending",
            "testStrategy": "Test store initialization, verify TypeScript types are correct, test basic state updates, validate initial state structure matches expected schema."
          },
          {
            "id": 2,
            "title": "Implement Auto-Save Hook with Debouncing",
            "description": "Create a custom React hook that handles automatic saving with 30-second debouncing and manual save triggers.",
            "dependencies": [
              1
            ],
            "details": "Create useAutoSave.ts hook that implements debounced saving every 30 seconds using lodash debounce or custom implementation. Include manual save triggers for navigation and field blur events. Integrate with React Query for API calls to Supabase. Handle save status updates and error states in the store.",
            "status": "pending",
            "testStrategy": "Test debouncing works correctly with 30-second intervals, verify manual save triggers fire immediately, test error handling and retry logic, validate save status updates in store."
          },
          {
            "id": 3,
            "title": "Implement Session Management Functions",
            "description": "Create core session management functions for initializing, saving, updating, and resetting wizard sessions.",
            "dependencies": [
              1
            ],
            "details": "Implement initializeSession() to create new wizard sessions with unique sessionId, saveWizardState() for persisting data to Supabase, updateStage() for navigation between stages, and resetWizard() for clearing state. Include proper error handling and validation for each function.",
            "status": "pending",
            "testStrategy": "Test session initialization creates valid sessionId, verify saveWizardState persists data correctly, test updateStage validates stage transitions, validate resetWizard clears all state properly."
          },
          {
            "id": 4,
            "title": "Add Offline Support with localStorage Backup",
            "description": "Implement offline functionality that backs up wizard state to localStorage when network is unavailable.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create offline detection using navigator.onLine and network event listeners. Implement localStorage backup system that saves wizard state when offline. Add sync mechanism to upload localStorage data when connection is restored. Handle conflict resolution between local and server state.",
            "status": "pending",
            "testStrategy": "Test offline detection works correctly, verify localStorage backup saves and restores data, test sync mechanism when coming back online, validate conflict resolution handles edge cases."
          },
          {
            "id": 5,
            "title": "Create Visual Save Indicators and Status UI",
            "description": "Build UI components that show save status, last saved timestamp, and visual feedback for auto-save operations.",
            "dependencies": [
              2
            ],
            "details": "Create SaveIndicator component that displays current save status (saving/saved/error) with appropriate icons and colors. Add LastSaved component showing timestamp of last successful save. Implement loading states and error messages. Include accessibility features like screen reader announcements for save status changes.",
            "status": "pending",
            "testStrategy": "Test save indicators update correctly for all status states, verify timestamps display accurate information, test accessibility features with screen readers, validate visual feedback is clear and intuitive."
          }
        ]
      },
      {
        "id": 3,
        "title": "Zod Validation Schemas for All Wizard Stages",
        "description": "Create comprehensive Zod validation schemas for all 6 wizard stages with real-time validation, cross-stage dependency validation, and accessibility-compliant error messaging.",
        "details": "Create validation schemas: stage1Schema (eventType, name 5-100 chars, date future only, attendeeCount 10-10000, description 50-500 chars, coverImage max 5MB), stage2Schema (detailedDescription 500-2000 chars, format required, accessibility array, logo max 2MB), stage3Schema (venue selection with capacity >= attendeeCount), stage4Schema (ticketTiers array with price > 0, quantity > 0, valid dates), stage5Schema (URLs validation, character limits), stage6Schema (terms checkbox, final cross-validation). Add real-time validation hook with debouncing. Error messages with aria-describedby for accessibility. Code: const stage1Schema = z.object({ eventType: z.enum(['conference', 'gala', 'product-launch', 'team-building', 'networking', 'workshop']), name: z.string().min(5).max(100), ... });",
        "testStrategy": "Test each field validation rule, verify character limits enforced, test cross-stage validation (venue capacity vs attendees), validate error messages display correctly, test accessibility attributes, verify real-time validation triggers on blur.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Stage 1 & 2 Zod Validation Schemas",
            "description": "Implement comprehensive Zod validation schemas for the first two wizard stages with proper field validation rules and error messages.",
            "dependencies": [],
            "details": "Create stage1Schema with eventType enum validation, name string validation (5-100 chars), date validation (future only), attendeeCount number validation (10-10000), description validation (50-500 chars), and coverImage file validation (max 5MB). Create stage2Schema with detailedDescription validation (500-2000 chars), format enum validation, accessibility array validation, and logo file validation (max 2MB). Include proper error messages for each field.",
            "status": "pending",
            "testStrategy": "Test each field validation rule individually, verify character limits are enforced, test file size validation for images, validate enum values are properly restricted, and ensure error messages are descriptive and accessible."
          },
          {
            "id": 2,
            "title": "Create Stage 3 & 4 Zod Validation Schemas",
            "description": "Implement Zod validation schemas for venue selection and ticketing stages with cross-stage dependency validation.",
            "dependencies": [
              1
            ],
            "details": "Create stage3Schema with venue selection validation ensuring venue capacity >= attendeeCount from stage 1, venue address validation, and facility requirements validation. Create stage4Schema with ticketTiers array validation including price validation (> 0), quantity validation (> 0), valid date ranges, early bird settings validation, and group discount validation. Implement cross-stage validation logic.",
            "status": "pending",
            "testStrategy": "Test venue capacity validation against attendee count, verify ticket tier array validation with dynamic add/remove, test price and quantity constraints, validate date range logic for early bird settings, and test cross-stage dependency validation."
          },
          {
            "id": 3,
            "title": "Create Stage 5 & 6 Zod Validation Schemas",
            "description": "Implement final validation schemas for marketing stage and review/publish stage with comprehensive validation rules.",
            "dependencies": [
              2
            ],
            "details": "Create stage5Schema with URL validation for social media links (Twitter, LinkedIn, Facebook), meta title validation (max 60 chars), meta description validation (max 160 chars), marketing description validation, and promotional image validation. Create stage6Schema with terms checkbox validation (required true), final cross-validation of all previous stages, and comprehensive event data validation before publishing.",
            "status": "pending",
            "testStrategy": "Test URL validation for social media platforms, verify character limits for SEO meta fields, test promotional image upload validation, validate terms checkbox requirement, and test comprehensive cross-stage validation logic."
          },
          {
            "id": 4,
            "title": "Implement Real-time Validation Hook with Debouncing",
            "description": "Create a custom React hook for real-time validation with debouncing to provide immediate feedback without performance issues.",
            "dependencies": [
              3
            ],
            "details": "Create useRealtimeValidation hook that accepts a Zod schema and form values, implements debouncing (300ms delay), provides real-time validation results, and manages validation state. Include error state management, loading states during validation, and integration with react-hook-form. Add proper TypeScript types and error handling for validation failures.",
            "status": "pending",
            "testStrategy": "Test debouncing functionality with rapid input changes, verify validation triggers correctly on field blur and change events, test integration with react-hook-form, validate error state management, and ensure performance is maintained with complex validation schemas."
          },
          {
            "id": 5,
            "title": "Implement Accessibility-Compliant Error Messaging System",
            "description": "Create an accessible error messaging system with proper ARIA attributes and screen reader support for all validation errors.",
            "dependencies": [
              4
            ],
            "details": "Implement error message components with aria-describedby attributes linking form fields to their error messages, aria-live regions for dynamic error announcements, proper error message formatting with clear descriptions, and integration with the validation schemas. Create ErrorMessage component with proper ARIA labeling, focus management for error states, and consistent styling across all wizard stages.",
            "status": "pending",
            "testStrategy": "Test screen reader compatibility with error messages, verify aria-describedby attributes are properly linked, test aria-live region announcements for dynamic errors, validate focus management when errors occur, and ensure error messages are clear and actionable for all users."
          }
        ]
      },
      {
        "id": 4,
        "title": "Stage 1 - Event Basics Form Implementation",
        "description": "Build the first wizard stage for event basics including event type selection, name input, date/time picker, attendee count, description, and cover image upload with validation.",
        "details": "Create Stage1.tsx component using existing FormCard, RadioCard components. Implement event type selection (6 radio options), text input for event name with character counter, date/time picker (react-datepicker) with future date validation, number input for attendee count with min/max, textarea for description with character counter, file upload for cover image with preview and size validation. Integrate with Zustand store and Zod validation. Add mobile-responsive design. Code: const Stage1 = () => { const { wizardState, updateStage } = useWizardStore(); const form = useForm({ resolver: zodResolver(stage1Schema), defaultValues: wizardState.stage1 }); return (<FormCard><RadioCard options={eventTypes} /><Input {...register('name')} /></FormCard>); };",
        "testStrategy": "Test all form fields render correctly, verify validation triggers on blur and submit, test file upload with size limits, validate mobile responsiveness, test integration with Zustand store, verify auto-save triggers on field changes.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Stage1 component structure and basic form setup",
            "description": "Set up the Stage1.tsx component with form initialization, Zustand store integration, and basic component structure using existing FormCard wrapper.",
            "dependencies": [],
            "details": "Create Stage1.tsx component file with useForm hook configured with zodResolver for stage1Schema validation. Initialize form with defaultValues from wizardState.stage1. Set up FormCard wrapper component and basic form structure. Import and configure useWizardStore hook for state management. Add form submission handler that calls updateStage method.",
            "status": "pending",
            "testStrategy": "Test component renders without errors, verify form initializes with correct default values from store, test form submission calls updateStage correctly"
          },
          {
            "id": 2,
            "title": "Implement event type selection with RadioCard components",
            "description": "Build the event type selection interface using existing RadioCard components with 6 predefined event type options and proper validation.",
            "dependencies": [
              1
            ],
            "details": "Create eventTypes array with 6 options (conference, workshop, networking, social, corporate, other) each with label, value, and description. Implement RadioCard component integration with react-hook-form register. Add proper styling and layout for mobile responsiveness. Ensure selection updates form state and triggers validation. Add visual feedback for selected state.",
            "status": "pending",
            "testStrategy": "Test all 6 event types render correctly, verify selection updates form state, test validation triggers on selection change, validate mobile responsive layout"
          },
          {
            "id": 3,
            "title": "Build event name input with character counter and validation",
            "description": "Implement event name text input field with real-time character counter, validation feedback, and proper error messaging for 5-100 character limit.",
            "dependencies": [
              1
            ],
            "details": "Create controlled Input component with register('name') binding. Add character counter display showing current/max characters (5-100). Implement real-time validation with error message display below input. Add proper styling for error states and success states. Ensure input is accessible with proper labels and aria attributes. Add debounced auto-save functionality.",
            "status": "pending",
            "testStrategy": "Test character counter updates in real-time, verify validation triggers at 5 and 100 character limits, test error message display, validate accessibility attributes"
          },
          {
            "id": 4,
            "title": "Implement date/time picker with future date validation",
            "description": "Build date and time selection using react-datepicker with validation to ensure only future dates can be selected, including proper timezone handling.",
            "dependencies": [
              1
            ],
            "details": "Install and configure react-datepicker component. Create custom DateTimePicker wrapper component with form integration. Implement minDate validation to prevent past date selection. Add timezone handling and display. Style picker to match design system. Add proper error handling and validation messages. Ensure mobile-friendly date picker interface.",
            "status": "pending",
            "testStrategy": "Test date picker prevents past date selection, verify time picker functionality, test timezone handling, validate mobile interface usability, test form integration"
          },
          {
            "id": 5,
            "title": "Build attendee count, description, and cover image upload components",
            "description": "Implement number input for attendee count (10-10000), textarea for description with character counter (50-500), and file upload for cover image with preview and size validation.",
            "dependencies": [
              1
            ],
            "details": "Create number input component for attendee count with min/max validation (10-10000). Build textarea component for description with character counter (50-500 chars) and real-time validation. Implement file upload component for cover image with drag-and-drop, preview functionality, size validation (max 5MB), and file type restrictions (jpg, png, webp). Add proper error handling and loading states for all components. Ensure mobile responsiveness.",
            "status": "pending",
            "testStrategy": "Test attendee count validation at boundaries, verify description character counter accuracy, test file upload with various file sizes and types, validate image preview functionality, test drag-and-drop upload"
          }
        ]
      },
      {
        "id": 5,
        "title": "Stage 2 - Event Details Form Implementation",
        "description": "Build the second wizard stage for detailed event information including format selection, accessibility requirements, branding options, and logo upload.",
        "details": "Create Stage2.tsx with detailed description textarea (500-2000 chars), event format radio buttons (in-person/virtual/hybrid), accessibility requirements checklist component, special requirements textarea, color picker for branding (react-colorful), logo upload with preview. Use existing UI components where possible. Add validation for required fields and character limits. Integrate with wizard store. Code: const Stage2 = () => { const accessibilityOptions = ['wheelchair-accessible', 'sign-language', 'audio-description', 'large-print']; return (<FormCard><Textarea maxLength={2000} /><RadioGroup options={formatOptions} /><TagSelector options={accessibilityOptions} /><ColorPicker /></FormCard>); };",
        "testStrategy": "Test format selection functionality, verify accessibility checklist multi-select, test color picker integration, validate logo upload with size restrictions, test character count validation, verify all fields save to store correctly.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Stage2 component structure with form layout",
            "description": "Create the basic Stage2.tsx component with FormCard wrapper and section layout for event details form",
            "dependencies": [],
            "details": "Create Stage2.tsx component using existing FormCard component. Set up the basic structure with sections for detailed description, event format, accessibility requirements, special requirements, branding, and logo upload. Import necessary UI components and establish the component layout following existing patterns from Stage1.",
            "status": "pending",
            "testStrategy": "Test component renders without errors, verify FormCard wrapper displays correctly, test responsive layout on different screen sizes"
          },
          {
            "id": 2,
            "title": "Implement detailed description textarea with character validation",
            "description": "Add detailed description textarea with 500-2000 character limit and real-time character counter",
            "dependencies": [
              1
            ],
            "details": "Implement Textarea component with minLength={500} and maxLength={2000} validation. Add character counter display showing current/max characters. Integrate with Zod validation schema for real-time validation. Add proper error messaging for character limit violations. Connect to wizard store for state management.",
            "status": "pending",
            "testStrategy": "Test character counter updates in real-time, verify validation triggers at 500 and 2000 character limits, test error messages display correctly"
          },
          {
            "id": 3,
            "title": "Build event format selection with radio buttons",
            "description": "Create event format selection using RadioGroup component for in-person, virtual, and hybrid options",
            "dependencies": [
              1
            ],
            "details": "Implement RadioGroup component with three options: 'in-person', 'virtual', 'hybrid'. Use existing RadioCard components for consistent styling. Add proper labels and descriptions for each format option. Integrate with wizard store and validation schema. Ensure selection is required and properly validated.",
            "status": "pending",
            "testStrategy": "Test radio button selection functionality, verify only one option can be selected, test validation for required field, verify store integration"
          },
          {
            "id": 4,
            "title": "Create accessibility requirements checklist and special requirements textarea",
            "description": "Implement TagSelector for accessibility options and textarea for special requirements",
            "dependencies": [
              1
            ],
            "details": "Create TagSelector component with accessibility options: 'wheelchair-accessible', 'sign-language', 'audio-description', 'large-print'. Allow multiple selections. Add special requirements textarea with appropriate character limits. Integrate both components with wizard store and validation. Ensure proper accessibility attributes for screen readers.",
            "status": "pending",
            "testStrategy": "Test multi-select functionality for accessibility options, verify special requirements textarea validation, test accessibility attributes with screen readers"
          },
          {
            "id": 5,
            "title": "Implement color picker and logo upload with preview",
            "description": "Add react-colorful color picker for branding and logo upload component with image preview functionality",
            "dependencies": [
              1
            ],
            "details": "Integrate react-colorful ColorPicker component for brand color selection. Implement logo upload component with file validation (max 2MB, image formats only), image preview functionality, and drag-and-drop support. Add proper error handling for file size and format validation. Connect both components to wizard store and ensure proper state management.",
            "status": "pending",
            "testStrategy": "Test color picker functionality and color value storage, verify logo upload with size restrictions, test image preview display, validate drag-and-drop functionality"
          }
        ]
      },
      {
        "id": 6,
        "title": "Stage 3 - Venue Selection Interface",
        "description": "Build venue selection interface with search, filtering, capacity validation, and multi-select capability for events requiring multiple spaces.",
        "details": "Create Stage3.tsx with venue search input (debounced), filter components for capacity/location/amenities, venue cards displaying images and details, multi-select functionality for multiple venues, real-time capacity validation against attendee count from Stage 1. Use existing venue data from database. Implement search with Supabase full-text search. Code: const Stage3 = () => { const [searchTerm, setSearchTerm] = useState(''); const debouncedSearch = useDebounce(searchTerm, 300); const { data: venues } = useQuery(['venues', debouncedSearch], () => searchVenues(debouncedSearch)); return (<div><Input placeholder='Search venues...' onChange={(e) => setSearchTerm(e.target.value)} /><VenueGrid venues={venues} onSelect={handleVenueSelect} /></div>); };",
        "testStrategy": "Test venue search with debouncing, verify filter functionality, test capacity validation against attendee count, validate multi-select venue functionality, test venue card display and selection, verify search performance with large datasets.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Stage3 component with search and filter UI",
            "description": "Build the main Stage3.tsx component with venue search input, filter controls, and basic layout structure.",
            "dependencies": [],
            "details": "Create Stage3.tsx component with debounced search input using useDebounce hook, filter components for capacity/location/amenities, and responsive layout. Include FormCard wrapper for consistency with other stages. Implement controlled input state management and basic UI structure following existing wizard patterns.",
            "status": "pending",
            "testStrategy": "Test search input renders correctly, verify debounce functionality works with 300ms delay, test filter components display properly, validate responsive layout on different screen sizes"
          },
          {
            "id": 2,
            "title": "Implement venue search API integration with Supabase",
            "description": "Create venue search functionality using Supabase full-text search with React Query integration.",
            "dependencies": [
              1
            ],
            "details": "Implement searchVenues API function using Supabase full-text search capabilities. Create React Query hook for venue fetching with proper caching and error handling. Include search by name, location, and amenities. Handle empty states and loading indicators. Follow existing API patterns from the codebase.",
            "status": "pending",
            "testStrategy": "Test search returns relevant venues, verify full-text search works across venue fields, test loading states and error handling, validate query caching behavior, test search performance with large datasets"
          },
          {
            "id": 3,
            "title": "Build VenueGrid component with venue cards and selection",
            "description": "Create venue display grid with individual venue cards showing images, details, and selection functionality.",
            "dependencies": [
              2
            ],
            "details": "Build VenueGrid component displaying venues in responsive grid layout. Create VenueCard component with venue images, capacity, location, amenities, and pricing. Implement single and multi-select functionality with visual selection indicators. Include venue details modal or expandable sections. Follow existing card design patterns.",
            "status": "pending",
            "testStrategy": "Test venue cards display all required information, verify image loading and fallbacks, test single/multi-select functionality, validate selection visual indicators, test responsive grid behavior"
          },
          {
            "id": 4,
            "title": "Implement capacity validation against attendee count",
            "description": "Add real-time capacity validation that checks selected venues against attendee count from Stage 1.",
            "dependencies": [
              3
            ],
            "details": "Implement capacity validation logic that compares total selected venue capacity against attendee count from wizardStore Stage 1 data. Show validation errors when capacity is insufficient. Add visual indicators for capacity status on venue cards. Include aggregate capacity display for multiple venue selections.",
            "status": "pending",
            "testStrategy": "Test capacity validation triggers correctly, verify error messages display when capacity insufficient, test validation updates when attendee count changes, validate aggregate capacity calculations for multiple venues"
          },
          {
            "id": 5,
            "title": "Integrate venue selection with wizard store and navigation",
            "description": "Connect venue selection to Zustand store with auto-save and implement stage navigation controls.",
            "dependencies": [
              4
            ],
            "details": "Integrate venue selection state with wizardStore, implementing updateStage function for Stage 3 data. Add auto-save functionality on venue selection changes. Implement stage navigation with validation checks. Include progress indicators and next/previous buttons following wizard navigation patterns. Handle venue data persistence and restoration.",
            "status": "pending",
            "testStrategy": "Test venue selections save to wizard store, verify auto-save triggers on selection changes, test navigation validation prevents proceeding without venue selection, validate data persistence across stage navigation"
          }
        ]
      },
      {
        "id": 7,
        "title": "Stage 4 - Dynamic Ticketing System",
        "description": "Build dynamic ticketing interface allowing multiple ticket tiers, pricing configuration, early bird settings, group discounts, and Canadian tax calculations.",
        "details": "Create Stage4.tsx with dynamic ticket tier management (add/remove), ticket name/price/quantity inputs, early bird toggle with date picker, group discount configuration, Canadian tax calculation (GST/PST/HST based on province), pricing preview component. Use react-hook-form's useFieldArray for dynamic tiers. Implement tax calculation utility for Canadian provinces. Code: const Stage4 = () => { const { fields, append, remove } = useFieldArray({ control, name: 'ticketTiers' }); const calculateTax = (price, province) => { const rates = { ON: 0.13, BC: 0.12, AB: 0.05 }; return price * (rates[province] || 0.05); }; return (<div>{fields.map((field, index) => (<TicketTierForm key={field.id} onRemove={() => remove(index)} />))}<Button onClick={() => append(defaultTier)}>Add Tier</Button></div>); };",
        "testStrategy": "Test dynamic addition/removal of ticket tiers, verify pricing calculations including taxes, test early bird date validation, validate group discount logic, test pricing preview updates, verify all ticket data saves correctly.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Stage4 component structure with dynamic ticket tier management",
            "description": "Build the main Stage4.tsx component with useFieldArray for dynamic ticket tier management",
            "dependencies": [],
            "details": "Create Stage4.tsx component using react-hook-form's useFieldArray to manage dynamic ticket tiers. Implement fields array, append function for adding new tiers, and remove function for deleting tiers. Set up the basic component structure with proper form integration from the wizard store.",
            "status": "pending",
            "testStrategy": "Test dynamic addition and removal of ticket tiers, verify form state updates correctly"
          },
          {
            "id": 2,
            "title": "Build TicketTierForm component with pricing inputs",
            "description": "Create individual ticket tier form component with name, price, quantity, and description inputs",
            "dependencies": [
              1
            ],
            "details": "Develop TicketTierForm component with controlled inputs for ticket name, price (with currency formatting), quantity limits, and optional description. Include validation for required fields and numeric constraints. Add remove button for each tier with confirmation.",
            "status": "pending",
            "testStrategy": "Test input validation, verify price formatting, test quantity limits and remove functionality"
          },
          {
            "id": 3,
            "title": "Implement Canadian tax calculation utility and province selector",
            "description": "Create tax calculation utility supporting GST/PST/HST rates for all Canadian provinces",
            "dependencies": [
              2
            ],
            "details": "Build calculateTax utility function with comprehensive Canadian tax rates (ON: 13% HST, BC: 12% GST+PST, AB: 5% GST, etc.). Create province selector dropdown component. Implement real-time tax calculation display for each ticket tier and total pricing.",
            "status": "pending",
            "testStrategy": "Test tax calculations for all provinces, verify rate accuracy, test province selection updates"
          },
          {
            "id": 4,
            "title": "Add early bird pricing and group discount configuration",
            "description": "Implement early bird toggle with date picker and group discount settings for ticket tiers",
            "dependencies": [
              3
            ],
            "details": "Add early bird pricing toggle for each ticket tier with date picker for cutoff date and discount percentage input. Implement group discount configuration with minimum quantity thresholds and discount rates. Include validation for date ranges and discount percentages.",
            "status": "pending",
            "testStrategy": "Test early bird date validation, verify group discount calculations, test discount logic combinations"
          },
          {
            "id": 5,
            "title": "Create pricing preview component with comprehensive calculations",
            "description": "Build pricing preview showing subtotals, taxes, discounts, and final totals for all ticket tiers",
            "dependencies": [
              4
            ],
            "details": "Develop PricingPreview component displaying itemized breakdown: base prices, early bird discounts, group discounts, tax calculations, and final totals. Include real-time updates as users modify ticket configurations. Add export/print functionality for pricing summary.",
            "status": "pending",
            "testStrategy": "Test pricing preview updates in real-time, verify all calculations display correctly, test export functionality"
          }
        ]
      },
      {
        "id": 8,
        "title": "Stage 5 - Event Marketing and SEO",
        "description": "Build marketing stage with SEO-optimized descriptions, social media links, meta tags, and promotional image upload for event promotion.",
        "details": "Create Stage5.tsx with marketing description textarea (SEO optimized), social media link inputs (Twitter, LinkedIn, Facebook) with URL validation, meta title input (max 60 chars), meta description input (max 160 chars), promotional image upload with preview. Add character counters and URL validation. Implement SEO preview component showing how event will appear in search results. Code: const Stage5 = () => { const socialPlatforms = ['twitter', 'linkedin', 'facebook']; return (<FormCard><Textarea placeholder='Marketing description...' maxLength={2000} />{socialPlatforms.map(platform => (<Input key={platform} type='url' placeholder={`${platform} URL`} {...register(`socialLinks.${platform}`)} />))}<SEOPreview title={watchTitle} description={watchDescription} /></FormCard>); };",
        "testStrategy": "Test URL validation for social links, verify character limits for meta fields, test promotional image upload, validate SEO preview component updates, test marketing description formatting, verify all marketing data saves properly.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Stage5.tsx component with marketing description textarea",
            "description": "Implement the main Stage5 component with SEO-optimized marketing description textarea including character counter and validation",
            "dependencies": [],
            "details": "Create Stage5.tsx component with FormCard wrapper containing a Textarea for marketing description with maxLength={2000}, placeholder text, character counter display, and real-time validation. Include proper form registration and error handling for the marketing description field.",
            "status": "pending",
            "testStrategy": "Test character limit enforcement, verify character counter updates in real-time, validate textarea saves properly, test error states and validation messages"
          },
          {
            "id": 2,
            "title": "Implement social media links inputs with URL validation",
            "description": "Add social media platform inputs for Twitter, LinkedIn, and Facebook with proper URL validation and error handling",
            "dependencies": [
              1
            ],
            "details": "Create social media inputs array mapping over ['twitter', 'linkedin', 'facebook'] platforms. Each input should have type='url', proper placeholder text, URL validation using Zod schema, and form registration with socialLinks.{platform} naming. Add validation error display and proper styling for each platform input.",
            "status": "pending",
            "testStrategy": "Test URL validation for each platform, verify invalid URLs show errors, test empty vs filled states, validate form registration works correctly for all social platforms"
          },
          {
            "id": 3,
            "title": "Add meta title and description inputs with character limits",
            "description": "Implement meta title input (max 60 chars) and meta description input (max 160 chars) with character counters and SEO guidance",
            "dependencies": [
              1
            ],
            "details": "Create meta title Input with maxLength={60} and meta description Textarea with maxLength={160}. Add character counters showing remaining characters, visual indicators when approaching limits, and SEO best practices tooltips. Include proper form registration and validation for both fields.",
            "status": "pending",
            "testStrategy": "Test character limits are enforced, verify character counters update correctly, test visual indicators at different character thresholds, validate SEO guidance displays properly"
          },
          {
            "id": 4,
            "title": "Implement promotional image upload with preview functionality",
            "description": "Create promotional image upload component with drag-and-drop, preview, and file validation for marketing purposes",
            "dependencies": [
              1
            ],
            "details": "Build image upload component supporting drag-and-drop and click-to-upload functionality. Include image preview, file size validation (max 5MB), accepted formats (jpg, png, webp), upload progress indicator, and remove/replace functionality. Integrate with form state management and provide proper error handling.",
            "status": "pending",
            "testStrategy": "Test file upload via drag-and-drop and click, verify file size and format validation, test image preview display, validate upload progress indicators, test remove/replace functionality"
          },
          {
            "id": 5,
            "title": "Create SEO preview component showing search result appearance",
            "description": "Build SEOPreview component that shows real-time preview of how the event will appear in search engine results",
            "dependencies": [
              2,
              3
            ],
            "details": "Create SEOPreview component that watches meta title and description fields to show a Google-style search result preview. Include event title truncation at 60 characters, description truncation at 160 characters, URL preview, and real-time updates as user types. Style to match actual search result appearance with proper typography and spacing.",
            "status": "pending",
            "testStrategy": "Test real-time preview updates as user types, verify character truncation works correctly, validate search result styling matches expectations, test preview with various title and description lengths"
          }
        ]
      },
      {
        "id": 9,
        "title": "Stage 6 - Review and Publish System",
        "description": "Build final review stage with comprehensive summary, edit navigation, final validation, terms acceptance, and event publishing functionality.",
        "details": "Create Stage6.tsx with summary sections for all previous stages, edit buttons linking back to specific stages, terms and conditions checkbox, final cross-stage validation, publish button with confirmation modal, success page with event URL. Implement event creation logic that transfers wizard data to events table. Add loading states and error handling. Code: const Stage6 = () => { const { wizardState, publishEvent } = useWizardStore(); const handlePublish = async () => { const isValid = await validateAllStages(); if (isValid && termsAccepted) { const event = await publishEvent(wizardState); router.push(`/events/${event.id}/success`); } }; return (<div><ReviewSummary data={wizardState} onEdit={navigateToStage} /><Checkbox {...register('termsAccepted')} required /><Button onClick={handlePublish} loading={isPublishing}>Publish Event</Button></div>); };",
        "testStrategy": "Test summary display for all stages, verify edit navigation functionality, test final validation across all stages, validate terms checkbox requirement, test event publishing process, verify success page navigation, test error handling for publish failures.",
        "priority": "high",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Stage6 Review Summary Component",
            "description": "Build comprehensive review summary component that displays all wizard data from previous stages in organized sections",
            "dependencies": [],
            "details": "Create ReviewSummary.tsx component that takes wizardState as props and renders organized sections for: Event Basics (type, name, date, attendees), Event Details (description, format, accessibility), Venue/Virtual (location or platform details), Ticketing (all tiers with pricing), and Schedule (agenda items). Include edit buttons for each section that call onEdit callback with stage number. Use existing UI components like Card, Badge, and Button for consistent styling.",
            "status": "pending",
            "testStrategy": "Test summary displays all wizard data correctly, verify edit buttons trigger navigation callbacks, test responsive layout on mobile devices, validate missing data handling"
          },
          {
            "id": 2,
            "title": "Implement Cross-Stage Validation System",
            "description": "Create comprehensive validation function that validates all wizard stages and returns detailed error information",
            "dependencies": [
              1
            ],
            "details": "Create validateAllStages() function in wizardStore that runs validation schemas for all 6 stages. Return validation results with stage-specific errors and overall validity status. Implement validation error display in Stage6 that shows which stages have issues with specific field errors. Add navigation to problematic stages with error highlighting. Use existing Zod schemas from each stage component.",
            "status": "pending",
            "testStrategy": "Test validation catches errors across all stages, verify error messages are specific and helpful, test navigation to stages with errors, validate error clearing when issues are fixed"
          },
          {
            "id": 3,
            "title": "Build Terms and Conditions Acceptance UI",
            "description": "Create terms acceptance checkbox with modal dialog for terms content and validation requirements",
            "dependencies": [
              2
            ],
            "details": "Create TermsAcceptance component with checkbox using react-hook-form register, modal dialog displaying terms and conditions content, required validation that prevents publishing without acceptance. Style with existing Checkbox and Modal components. Include links to privacy policy and terms of service. Add visual indication that terms must be accepted before publishing.",
            "status": "pending",
            "testStrategy": "Test terms modal opens and displays content correctly, verify checkbox validation prevents publishing when unchecked, test form submission only works when terms are accepted"
          },
          {
            "id": 4,
            "title": "Implement Event Publishing Logic and API Integration",
            "description": "Create publishEvent function that transforms wizard data and creates event record in Supabase database",
            "dependencies": [
              3
            ],
            "details": "Implement publishEvent() function in wizardStore that: transforms wizardState to match events table schema, handles file uploads for cover image and logos to Supabase storage, creates event record with all related data (tickets, schedule items), returns created event with ID. Add error handling for network issues, validation failures, and database constraints. Include loading states and progress indicators during publishing process.",
            "status": "pending",
            "testStrategy": "Test event creation with complete wizard data, verify file uploads work correctly, test error handling for various failure scenarios, validate loading states during publishing process"
          },
          {
            "id": 5,
            "title": "Create Success Page and Confirmation Modal",
            "description": "Build publish confirmation modal and success page with event URL and sharing options",
            "dependencies": [
              4
            ],
            "details": "Create PublishConfirmationModal component with event summary and confirmation buttons. Build EventSuccessPage component that displays: event URL, sharing buttons (social media, email, copy link), next steps guidance, dashboard navigation link. Include celebration animation or visual feedback. Add error boundary for handling post-publish issues. Style with existing Modal and Button components for consistency.",
            "status": "pending",
            "testStrategy": "Test confirmation modal shows correct event details, verify success page displays proper event URL, test sharing functionality works correctly, validate navigation to event dashboard"
          }
        ]
      },
      {
        "id": 10,
        "title": "Session Management and Recovery System",
        "description": "Implement session initialization, recovery, cleanup, and error handling to ensure zero data loss and seamless user experience across browser sessions.",
        "details": "Create session management utilities: initializeWizardSession() for new sessions, recoverWizardSession() for returning users, cleanupOldSessions() for maintenance. Implement session timeout handling (24 hours), browser refresh recovery, tab close detection with save, error recovery mechanisms. Add session monitoring and health checks. Create API endpoints for session CRUD operations using Supabase Edge Functions. Code: const SessionManager = { async initializeSession(userId) { const session = await supabase.from('wizard_sessions').insert({ user_id: userId, status: 'in_progress', state: {}, started_at: new Date() }).select().single(); return session; }, async recoverSession(sessionId) { const session = await supabase.from('wizard_sessions').select('*').eq('id', sessionId).single(); if (session && !isExpired(session)) return session; return null; } };",
        "testStrategy": "Test session creation and recovery, verify session timeout handling, test browser refresh recovery, validate tab close save functionality, test cleanup of expired sessions, verify error recovery mechanisms, test concurrent session handling.",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Session Management Core Utilities",
            "description": "Implement the core SessionManager class with initialization, recovery, and cleanup methods for wizard sessions.",
            "dependencies": [],
            "details": "Create src/lib/session-manager.ts with SessionManager class containing initializeSession(), recoverSession(), cleanupOldSessions(), and isExpired() methods. Implement session timeout logic (24 hours), state validation, and error handling. Include TypeScript interfaces for session data structures.",
            "status": "pending",
            "testStrategy": "Unit tests for each method, test session expiration logic, verify error handling for invalid sessions"
          },
          {
            "id": 2,
            "title": "Implement Browser Event Handlers for Session Persistence",
            "description": "Add browser event listeners for beforeunload, visibilitychange, and storage events to handle session persistence across browser interactions.",
            "dependencies": [
              1
            ],
            "details": "Create src/hooks/useSessionPersistence.ts hook that listens to beforeunload (tab close), visibilitychange (tab switch), and storage events. Implement auto-save functionality that triggers on these events. Add debounced save to prevent excessive API calls during rapid form changes.",
            "status": "pending",
            "testStrategy": "Test tab close detection and save, verify browser refresh recovery, test storage event handling across tabs"
          },
          {
            "id": 3,
            "title": "Create Supabase Edge Functions for Session CRUD Operations",
            "description": "Implement serverless functions for session create, read, update, delete operations with proper authentication and validation.",
            "dependencies": [
              1
            ],
            "details": "Create supabase/functions/session-manager/index.ts with endpoints for POST /sessions (create), GET /sessions/:id (read), PUT /sessions/:id (update), DELETE /sessions/:id (delete). Implement JWT authentication, input validation using Zod schemas, and proper error responses. Add session cleanup endpoint for expired sessions.",
            "status": "pending",
            "testStrategy": "Test all CRUD operations, verify authentication requirements, test input validation, verify cleanup functionality"
          },
          {
            "id": 4,
            "title": "Add Session Monitoring and Health Check System",
            "description": "Implement session health monitoring with periodic checks, error recovery mechanisms, and session state validation.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create src/lib/session-monitor.ts with health check intervals, connection status monitoring, and automatic recovery for failed saves. Implement retry logic with exponential backoff, offline detection, and queue management for failed operations. Add session state integrity validation.",
            "status": "pending",
            "testStrategy": "Test health check intervals, verify retry logic, test offline/online detection, validate session state integrity checks"
          },
          {
            "id": 5,
            "title": "Integrate Session Management with Wizard Store",
            "description": "Connect the session management system with the existing wizard store to enable automatic session persistence and recovery.",
            "dependencies": [
              4
            ],
            "details": "Modify src/store/wizard-store.ts to integrate SessionManager, add session initialization on wizard start, implement automatic state persistence on changes, and session recovery on page load. Add session ID tracking and error state management. Ensure seamless integration with existing wizard flow.",
            "status": "pending",
            "testStrategy": "Test wizard initialization with session recovery, verify automatic state persistence, test error handling integration, validate session ID tracking"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-13T13:16:32.712Z",
      "updated": "2025-10-13T13:16:32.712Z",
      "description": "Tasks for master context"
    }
  }
}